<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>–õ–æ–≥–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏</title>
    <style>
      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        background: linear-gradient(
          135deg,
          #1a1a2e 0%,
          #16213e 50%,
          #0f3460 100%
        );
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 900px;
        margin: 0 auto;
      }

      h1 {
        text-align: center;
        color: white;
        margin-bottom: 20px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        font-size: 1.6rem;
      }

      .back-link {
        display: inline-block;
        background: rgba(255, 255, 255, 0.2);
        color: white;
        text-decoration: none;
        padding: 10px 20px;
        border-radius: 25px;
        margin-bottom: 20px;
        transition: background 0.3s;
      }

      .back-link:hover {
        background: rgba(255, 255, 255, 0.3);
      }

      .instructions {
        background: rgba(255, 255, 255, 0.95);
        padding: 15px 20px;
        border-radius: 10px;
        margin-bottom: 20px;
        text-align: center;
        font-size: 0.95rem;
        color: #333;
      }

      .task-card {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 15px;
        padding: 25px;
        margin-bottom: 20px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      }

      .task-text {
        font-size: 1.1rem;
        line-height: 1.8;
        color: #333;
        margin-bottom: 25px;
      }

      .task-text .highlight {
        background: linear-gradient(145deg, #e94560 0%, #ff6b6b 100%);
        color: white;
        padding: 2px 8px;
        border-radius: 5px;
        font-weight: bold;
      }

      .logic-table-container {
        overflow-x: auto;
        margin: 20px 0;
      }

      .logic-table {
        width: 100%;
        border-collapse: collapse;
        background: white;
        border-radius: 10px;
        overflow: hidden;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      }

      .logic-table th,
      .logic-table td {
        border: 2px solid #e0e0e0;
        padding: 0;
        text-align: center;
        min-width: 80px;
      }

      .logic-table th {
        background: linear-gradient(145deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 12px 8px;
        font-weight: 600;
        font-size: 0.95rem;
      }

      .logic-table th.name-header {
        background: linear-gradient(145deg, #11998e 0%, #38ef7d 100%);
        min-width: 120px;
      }

      .logic-table td.name-cell {
        background: linear-gradient(145deg, #11998e 0%, #38ef7d 100%);
        color: white;
        padding: 12px 15px;
        font-weight: 600;
        text-align: left;
      }

      .logic-table td.clickable {
        cursor: pointer;
        transition: all 0.2s;
        user-select: none;
        min-height: 50px;
        height: 50px;
      }

      .logic-table td.clickable:hover {
        background: rgba(102, 126, 234, 0.1);
      }

      .logic-table td.clickable.plus {
        background: rgba(17, 153, 142, 0.2);
        color: #11998e;
        font-size: 1.5rem;
        font-weight: bold;
      }

      .logic-table td.clickable.minus {
        background: rgba(235, 51, 73, 0.15);
        color: #eb3349;
        font-size: 1.5rem;
        font-weight: bold;
      }

      .logic-table td.clickable.correct {
        background: rgba(17, 153, 142, 0.3);
        border-color: #38ef7d;
      }

      .logic-table td.clickable.incorrect {
        background: rgba(235, 51, 73, 0.3);
        border-color: #f45c43;
      }

      .logic-table td.clickable.correct-minus {
        background: rgba(17, 153, 142, 0.2);
        border-color: #38ef7d;
      }

      .buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
        flex-wrap: wrap;
        margin-top: 20px;
      }

      .btn {
        border: none;
        padding: 12px 25px;
        border-radius: 25px;
        font-size: 1rem;
        cursor: pointer;
        transition:
          transform 0.2s,
          box-shadow 0.2s;
        font-weight: 500;
      }

      .btn:hover {
        transform: translateY(-2px);
      }

      .btn-check {
        background: linear-gradient(145deg, #11998e 0%, #38ef7d 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(17, 153, 142, 0.4);
      }

      .btn-clear {
        background: linear-gradient(145deg, #ff6b6b 0%, #ee5a24 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
      }

      .btn-reset {
        background: linear-gradient(145deg, #f093fb 0%, #f5576c 100%);
        color: white;
        box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4);
      }

      .feedback {
        margin-top: 20px;
        padding: 15px;
        border-radius: 10px;
        text-align: center;
        font-weight: bold;
        display: none;
      }

      .feedback.correct {
        display: block;
        background: linear-gradient(145deg, #11998e 0%, #38ef7d 100%);
        color: white;
      }

      .feedback.incorrect {
        display: block;
        background: linear-gradient(145deg, #eb3349 0%, #f45c43 100%);
        color: white;
      }

      .correct-answer {
        margin-top: 10px;
        font-size: 0.9rem;
        color: #fff;
      }

      .legend {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-top: 15px;
        flex-wrap: wrap;
      }

      .legend-item {
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 0.9rem;
        color: #555;
      }

      .legend-box {
        width: 30px;
        height: 30px;
        border: 2px solid #e0e0e0;
        border-radius: 5px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: bold;
      }

      .legend-box.plus {
        background: rgba(17, 153, 142, 0.2);
        color: #11998e;
      }

      .legend-box.minus {
        background: rgba(235, 51, 73, 0.15);
        color: #eb3349;
      }

      .legend-box.empty {
        background: white;
      }

      .hint-box {
        background: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 12px 15px;
        margin-top: 20px;
        border-radius: 0 8px 8px 0;
        font-size: 0.9rem;
      }

      .hint-box strong {
        color: #856404;
      }

      .reasoning-steps {
        margin-top: 15px;
        padding: 15px;
        background: #f8f9fa;
        border-radius: 10px;
        display: none;
      }

      .reasoning-steps h4 {
        color: #333;
        margin-bottom: 10px;
        text-align: center;
      }

      .reasoning-steps ol {
        margin-left: 20px;
        color: #555;
        line-height: 1.8;
      }

      .reasoning-steps li {
        margin-bottom: 5px;
      }

      @media (max-width: 600px) {
        h1 {
          font-size: 1.3rem;
        }

        .task-text {
          font-size: 1rem;
        }

        .logic-table th,
        .logic-table td.name-cell {
          padding: 8px 5px;
          font-size: 0.85rem;
        }

        .logic-table td.clickable {
          min-width: 60px;
          height: 45px;
        }

        .btn {
          padding: 10px 20px;
          font-size: 0.9rem;
        }

        .legend {
          flex-direction: column;
          align-items: center;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <a href="vpr7.html" class="back-link">‚Üê –ù–∞ –≥–ª–∞–≤–Ω—É—é</a>
      <h1>üß© –õ–æ–≥–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞—á–∏</h1>

      <div class="instructions">
        –ö–ª–∏–∫–∞–π—Ç–µ –Ω–∞ —è—á–µ–π–∫–∏ —Ç–∞–±–ª–∏—Ü—ã –¥–ª—è –ø–æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–ª—é—Å–æ–≤ –∏ –º–∏–Ω—É—Å–æ–≤. –ó–∞–ø–æ–ª–Ω–∏—Ç–µ
        —Ç–∞–±–ª–∏—Ü—É –ª–æ–≥–∏—á–µ—Å–∫–∏–º–∏ –≤—ã–≤–æ–¥–∞–º–∏.
      </div>

      <div class="task-card">
        <div class="task-text" id="taskText">–ó–∞–≥—Ä—É–∑–∫–∞ –∑–∞–¥–∞–Ω–∏—è...</div>

        <div class="logic-table-container">
          <table class="logic-table" id="logicTable">
            <thead>
              <tr>
                <th class="name-header">–ò–º—è / –§–∞–º–∏–ª–∏—è</th>
                <th id="surname1">-</th>
                <th id="surname2">-</th>
                <th id="surname3">-</th>
              </tr>
            </thead>
            <tbody id="tableBody"></tbody>
          </table>
        </div>

        <div class="legend">
          <div class="legend-item">
            <div class="legend-box empty"></div>
            <span>–ü—É—Å—Ç–æ (–∫–ª–∏–∫–Ω–∏—Ç–µ)</span>
          </div>
          <div class="legend-item">
            <div class="legend-box plus">+</div>
            <span>–ü–ª—é—Å (—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç)</span>
          </div>
          <div class="legend-item">
            <div class="legend-box minus">‚àí</div>
            <span>–ú–∏–Ω—É—Å (–Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç)</span>
          </div>
        </div>

        <div class="hint-box" id="hintBox" style="display: none">
          <strong>üí° –ü–æ–¥—Å–∫–∞–∑–∫–∞:</strong> <span id="hintText"></span>
        </div>

        <div class="feedback" id="feedback">
          <div id="feedbackText"></div>
          <div class="correct-answer" id="correctAnswer"></div>
        </div>

        <div class="reasoning-steps" id="reasoningSteps">
          <h4>–•–æ–¥ —Ä–∞—Å—Å—É–∂–¥–µ–Ω–∏–π:</h4>
          <ol id="reasoningList"></ol>
        </div>

        <div class="buttons">
          <button class="btn btn-check" onclick="checkAnswer()">
            ‚úì –ü—Ä–æ–≤–µ—Ä–∏—Ç—å
          </button>
          <button class="btn btn-clear" onclick="clearAll()">‚úï –û—á–∏—Å—Ç–∏—Ç—å</button>
          <button class="btn btn-reset" onclick="resetGame()">
            üîÑ –ù–æ–≤–∞—è –∑–∞–¥–∞—á–∞
          </button>
        </div>
      </div>
    </div>

    <script>
      let femaleNames = [];
      let maleNames = [];
      let femaleSurnames = [];
      let maleSurnames = [];

      let currentTask = null;
      let answered = false;

      // –°–∫–ª–æ–Ω–µ–Ω–∏–µ –∏–º—ë–Ω (—Ä–æ–¥–∏—Ç–µ–ª—å–Ω—ã–π –ø–∞–¥–µ–∂ - "—É –∫–æ–≥–æ?")
      function declineNameGenitive(name, isFemale) {
        // –ñ–µ–Ω—Å–∫–∏–µ –∏–º–µ–Ω–∞
        if (isFemale) {
          // –ò–º–µ–Ω–∞ –Ω–∞ -–∞ -> -—ã –∏–ª–∏ -–∏ –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º —Ä—É—Å—Å–∫–æ–π –æ—Ä—Ñ–æ–≥—Ä–∞—Ñ–∏–∏
          // –ü–æ—Å–ª–µ –≥, –∫, —Ö, –∂, —à, —á, —â –ø–∏—à–µ—Ç—Å—è -–∏ (–û–ª—å–≥–∞ -> –û–ª—å–≥–∏, –í–∏–∫–∞ -> –í–∏–∫–∏)
          // –ü–æ—Å–ª–µ –¥—Ä—É–≥–∏—Ö —Å–æ–≥–ª–∞—Å–Ω—ã—Ö –ø–∏—à–µ—Ç—Å—è -—ã (–ê–Ω–Ω–∞ -> –ê–Ω–Ω—ã, –ò—Ä–∏–Ω–∞ -> –ò—Ä–∏–Ω—ã)
          if (name.endsWith("–∞")) {
            const beforeLast = name.slice(-2, -1).toLowerCase();
            if (/[–≥–∫—Ö–∂—à—á—â]/.test(beforeLast)) {
              return name.slice(0, -1) + "–∏";
            }
            return name.slice(0, -1) + "—ã";
          }
          // –ò–º–µ–Ω–∞ –Ω–∞ -—è -> -–∏ (–°–æ—Ñ–∏—è -> –°–æ—Ñ–∏–∏, –ú–∞—Ä–∏—è -> –ú–∞—Ä–∏–∏)
          if (name.endsWith("—è")) {
            return name.slice(0, -1) + "–∏";
          }
          // –ò–º–µ–Ω–∞ –Ω–∞ –º—è–≥–∫–∏–π –∑–Ω–∞–∫ -> -–∏ (–õ—é–±–æ–≤—å -> –õ—é–±–æ–≤–∏)
          if (name.endsWith("—å")) {
            return name.slice(0, -1) + "–∏";
          }
          return name;
        }
        // –ú—É–∂—Å–∫–∏–µ –∏–º–µ–Ω–∞
        else {
          // –ò–º–µ–Ω–∞ –Ω–∞ -–π -> -—è (–ê–Ω–¥—Ä–µ–π -> –ê–Ω–¥—Ä–µ—è, –°–µ—Ä–≥–µ–π -> –°–µ—Ä–≥–µ—è)
          // –í–ê–ñ–ù–û: –ø—Ä–æ–≤–µ—Ä—è–µ–º –î–û —Å–æ–≥–ª–∞—Å–Ω—ã—Ö, —Ç–∞–∫ –∫–∞–∫ "–π" —Ç–æ–∂–µ —Å–æ–≥–ª–∞—Å–Ω–∞—è
          if (name.endsWith("–π")) {
            return name.slice(0, -1) + "—è";
          }
          // –ò–º–µ–Ω–∞ –Ω–∞ —Å–æ–≥–ª–∞—Å–Ω—É—é -> -–∞ (–ú–∞–∫—Å–∏–º -> –ú–∞–∫—Å–∏–º–∞, –ê–ª–µ–∫—Å–∞–Ω–¥—Ä -> –ê–ª–µ–∫—Å–∞–Ω–¥—Ä–∞)
          if (/[–±–≤–≥–¥–∂–∑–∫–ª–º–Ω–ø—Ä—Å—Ç—Ñ—Ö—Ü—á—à—â]$/.test(name)) {
            return name + "–∞";
          }
          // –ò–º–µ–Ω–∞ –Ω–∞ -–∞ -> -—ã (–ù–∏–∫–∏—Ç–∞ -> –ù–∏–∫–∏—Ç—ã)
          if (name.endsWith("–∞")) {
            return name.slice(0, -1) + "—ã";
          }
          // –ò–º–µ–Ω–∞ –Ω–∞ -—è -> -–∏ (–ò–ª—å—è -> –ò–ª—å–∏)
          if (name.endsWith("—è")) {
            return name.slice(0, -1) + "–∏";
          }
          return name;
        }
      }

      // –°–∫–ª–æ–Ω–µ–Ω–∏–µ —Ñ–∞–º–∏–ª–∏–π (—Ä–æ–¥–∏—Ç–µ–ª—å–Ω—ã–π –ø–∞–¥–µ–∂)
      function declineSurnameGenitive(surname, isFemale) {
        if (isFemale) {
          // –ñ–µ–Ω—Å–∫–∏–µ —Ñ–∞–º–∏–ª–∏–∏ –Ω–∞ -–∞ -> -–æ–π (–ò–≤–∞–Ω–æ–≤–∞ -> –ò–≤–∞–Ω–æ–≤–æ–π)
          if (surname.endsWith("–∞")) {
            return surname.slice(0, -1) + "–æ–π";
          }
          return surname;
        } else {
          // –ú—É–∂—Å–∫–∏–µ —Ñ–∞–º–∏–ª–∏–∏ –Ω–∞ —Å–æ–≥–ª–∞—Å–Ω—É—é -> -–∞ (–ò–≤–∞–Ω–æ–≤ -> –ò–≤–∞–Ω–æ–≤–∞)
          if (/[–±–≤–≥–¥–∂–∑–π–∫–ª–º–Ω–ø—Ä—Å—Ç—Ñ—Ö—Ü—á—à—â]$/.test(surname)) {
            return surname + "–∞";
          }
          // –§–∞–º–∏–ª–∏–∏ –Ω–∞ -–π -> -—è (–ë–µ–ª—ã–π -> –ë–µ–ª–æ–≥–æ)
          if (surname.endsWith("–π")) {
            return surname.slice(0, -1) + "—è";
          }
          // –§–∞–º–∏–ª–∏–∏ –Ω–∞ -–æ –Ω–µ —Å–∫–ª–æ–Ω—è—é—Ç—Å—è (–§–æ–º–∏–Ω–æ -> –§–æ–º–∏–Ω–æ)
          if (surname.endsWith("–æ")) {
            return surname;
          }
          return surname;
        }
      }

      // –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ñ–∞–π–ª–∞
      async function loadData() {
        try {
          const response = await fetch("vpr7-5.txt");
          const text = await response.text();
          parseData(text);
          startGame();
        } catch (error) {
          console.error("–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö:", error);
          // Fallback –¥–∞–Ω–Ω—ã–µ
          femaleNames = [
            "–ú–∞—Ä–∏—è",
            "–ò—Ä–∏–Ω–∞",
            "–°–≤–µ—Ç–ª–∞–Ω–∞",
            "–ê–Ω–Ω–∞",
            "–ï–ª–µ–Ω–∞",
            "–û–ª—å–≥–∞",
          ];
          maleNames = [
            "–ê–ª–µ–∫—Å–∞–Ω–¥—Ä",
            "–î–º–∏—Ç—Ä–∏–π",
            "–ú–∞–∫—Å–∏–º",
            "–°–µ—Ä–≥–µ–π",
            "–ê–Ω–¥—Ä–µ–π",
            "–ê–ª–µ–∫—Å–µ–π",
          ];
          femaleSurnames = [
            "–ú–∏—Ä–æ–Ω–æ–≤–∞",
            "–ò–≤–∞–Ω–æ–≤–∞",
            "–°–µ—Ä–≥–µ–µ–≤–∞",
            "–ü–µ—Ç—Ä–æ–≤–∞",
            "–°–∏–¥–æ—Ä–æ–≤–∞",
            "–ö–æ–∑–ª–æ–≤–∞",
          ];
          maleSurnames = [
            "–ú–∏—Ä–æ–Ω–æ–≤",
            "–ò–≤–∞–Ω–æ–≤",
            "–°–µ—Ä–≥–µ–µ–≤",
            "–ü–µ—Ç—Ä–æ–≤",
            "–°–∏–¥–æ—Ä–æ–≤",
            "–ö–æ–∑–ª–æ–≤",
          ];
          startGame();
        }
      }

      // –ü–∞—Ä—Å–∏–Ω–≥ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ñ–∞–π–ª–∞
      function parseData(text) {
        const lines = text.split("\n");
        let currentSection = "";

        lines.forEach((line) => {
          line = line.trim();
          if (line.startsWith("# –ò–º–µ–Ω–∞ (–∂–µ–Ω—Å–∫–∏–µ)")) {
            currentSection = "femaleNames";
          } else if (line.startsWith("# –ò–º–µ–Ω–∞ (–º—É–∂—Å–∫–∏–µ)")) {
            currentSection = "maleNames";
          } else if (line.startsWith("# –§–∞–º–∏–ª–∏–∏ (–∂–µ–Ω—Å–∫–∏–µ)")) {
            currentSection = "femaleSurnames";
          } else if (line.startsWith("# –§–∞–º–∏–ª–∏–∏ (–º—É–∂—Å–∫–∏–µ)")) {
            currentSection = "maleSurnames";
          } else if (line.startsWith("# –§–∞–º–∏–ª–∏–∏ (–æ–±—â–∏–µ)")) {
            currentSection = ""; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –æ–±—â–∏–µ —Ñ–∞–º–∏–ª–∏–∏
          } else if (line && !line.startsWith("#")) {
            if (currentSection === "femaleNames") femaleNames.push(line);
            else if (currentSection === "maleNames") maleNames.push(line);
            else if (currentSection === "femaleSurnames")
              femaleSurnames.push(line);
            else if (currentSection === "maleSurnames") maleSurnames.push(line);
          }
        });
      }

      // –ù–∞—á–∞–ª–æ –∏–≥—Ä—ã
      function startGame() {
        generateTask();
      }

      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–¥–∞–Ω–∏—è
      function generateTask() {
        answered = false;
        document.getElementById("feedback").className = "feedback";
        document.getElementById("feedback").style.display = "none";
        document.getElementById("hintBox").style.display = "none";
        document.getElementById("reasoningSteps").style.display = "none";

        // –í—ã–±–∏—Ä–∞–µ–º —Ç–∏–ø –∑–∞–¥–∞—á–∏ (–º—É–∂—á–∏–Ω—ã –∏–ª–∏ –∂–µ–Ω—â–∏–Ω—ã)
        const useFemale = Math.random() > 0.5;
        const names = useFemale ? femaleNames : maleNames;
        const surnames = useFemale ? femaleSurnames : maleSurnames;
        const personType = useFemale ? "–¥–µ–≤–æ—á–∫–∏" : "–º–∞–ª—å—á–∏–∫–∏";

        // –í—ã–±–∏—Ä–∞–µ–º 3 –∏–º–µ–Ω–∏ –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Ñ–∞–º–∏–ª–∏–∏
        const selectedIndices = [];
        while (selectedIndices.length < 3) {
          const idx = Math.floor(Math.random() * names.length);
          if (!selectedIndices.includes(idx)) {
            selectedIndices.push(idx);
          }
        }

        const selectedNames = selectedIndices.map((i) => names[i]);
        const selectedSurnames = selectedIndices.map((i) => surnames[i]);

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∑–∞–¥–∞—á—É —Å —É—Å–ª–æ–≤–∏—è–º–∏
        const task = generatePuzzle(
          selectedNames,
          selectedSurnames,
          personType,
        );

        if (!task) {
          // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å, –ø—Ä–æ–±—É–µ–º —Å–Ω–æ–≤–∞
          generateTask();
          return;
        }

        currentTask = task;
        renderTask();
      }

      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≥–æ–ª–æ–≤–æ–ª–æ–º–∫–∏ —Å —É—Å–ª–æ–≤–∏—è–º–∏
      function generatePuzzle(names, surnames, personType) {
        // –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–π —à–∞–±–ª–æ–Ω –∑–∞–¥–∞—á–∏
        const templates = [
          generateTemplate1, // –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π —à–∞–±–ª–æ–Ω —Å –∏—Å–∫–ª—é—á–µ–Ω–∏–µ–º
          generateTemplate2, // –®–∞–±–ª–æ–Ω —Å –±—É–∫–≤–∞–º–∏ –≤ —Ñ–∞–º–∏–ª–∏–∏
          generateTemplate3, // –®–∞–±–ª–æ–Ω —Å –ø–µ—Ä–≤—ã–º–∏ –±—É–∫–≤–∞–º–∏
          generateTemplate4, // –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —à–∞–±–ª–æ–Ω
        ];

        // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º —à–∞–±–ª–æ–Ω—ã –∏ –ø—Ä–æ–±—É–µ–º –∫–∞–∂–¥—ã–π
        const shuffledTemplates = [...templates].sort(
          () => Math.random() - 0.5,
        );

        for (const template of shuffledTemplates) {
          const result = template(names, surnames, personType);
          if (result) {
            return result;
          }
        }

        return null;
      }

      // –®–∞–±–ª–æ–Ω 1: –ö–ª–∞—Å—Å–∏—á–µ—Å–∫–∏–π (–ê –Ω–µ –ë, –í –∏ –ì –∏–º–µ—é—Ç –æ–±—â—É—é –±—É–∫–≤—É, –î –Ω–µ –ï)
      function generateTemplate1(names, surnames, personType) {
        const isFemale = personType === "–¥–µ–≤–æ—á–∫–∏";

        // –°–ª—É—á–∞–π–Ω–æ –Ω–∞–∑–Ω–∞—á–∞–µ–º —Ñ–∞–º–∏–ª–∏–∏
        const shuffledSurnames = [...surnames];
        for (let i = shuffledSurnames.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [shuffledSurnames[i], shuffledSurnames[j]] = [
            shuffledSurnames[j],
            shuffledSurnames[i],
          ];
        }

        const matches = names.map((name, i) => ({
          name: name,
          surname: shuffledSurnames[i],
        }));

        const conditions = [];
        const getSurname = (name) => shuffledSurnames[names.indexOf(name)];

        // –£—Å–ª–æ–≤–∏–µ 1: –ê –Ω–µ –ë (–æ—Ç—Ä–∏—Ü–∞–Ω–∏–µ)
        const name1 = names[0];
        const wrongSurname = shuffledSurnames[1]; // –§–∞–º–∏–ª–∏—è –≤—Ç–æ—Ä–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞
        conditions.push({
          type: "notSurname",
          text: `<span class="highlight">${name1}</span> –Ω–µ <span class="highlight">${wrongSurname}</span>.`,
          relevantInfo: {
            name: name1,
            notSurname: wrongSurname,
            actualSurname: getSurname(name1),
          },
        });

        // –£—Å–ª–æ–≤–∏–µ 2: –ù–∞—Ö–æ–¥–∏–º –æ–±—â—É—é –±—É–∫–≤—É –≤ —Ñ–∞–º–∏–ª–∏—è—Ö –¥–≤—É—Ö —á–µ–ª–æ–≤–µ–∫
        const name2 = names[1];
        const name3 = names[2];
        const surname1 = getSurname(name1);
        const surname2 = getSurname(name2);
        const surname3 = getSurname(name3);

        // –ò—â–µ–º –æ–±—â—É—é –±—É–∫–≤—É, –∫–æ—Ç–æ—Ä–∞—è –µ—Å—Ç—å –¢–û–õ–¨–ö–û –≤ surname2 –∏ surname3, –Ω–æ –ù–ï –≤ surname1
        let commonLetter = null;
        for (const letter of surname2.toLowerCase()) {
          if (
            surname3.toLowerCase().includes(letter) &&
            !surname1.toLowerCase().includes(letter)
          ) {
            commonLetter = letter;
            break;
          }
        }

        if (commonLetter) {
          const name2Gen = declineNameGenitive(name2, isFemale);
          const name3Gen = declineNameGenitive(name3, isFemale);
          const name1Gen = declineNameGenitive(name1, isFemale);
          conditions.push({
            type: "sameLetterInSurname",
            text: `–£ <span class="highlight">${name2Gen}</span> –∏ —É <span class="highlight">${name3Gen}</span> –≤ —Ñ–∞–º–∏–ª–∏–∏ –µ—Å—Ç—å –±—É–∫–≤–∞ ¬´${commonLetter.toUpperCase()}¬ª (–∞ —É <span class="highlight">${name1Gen}</span> —Ç–∞–∫–æ–π –±—É–∫–≤—ã –≤ —Ñ–∞–º–∏–ª–∏–∏ –Ω–µ—Ç).`,
            relevantInfo: {
              person1: name2,
              person2: name3,
              letter: commonLetter,
              surnames: [surname2, surname3],
              excludedPerson: name1,
            },
          });
        } else {
          // –ï—Å–ª–∏ –æ–±—â–∞—è –±—É–∫–≤–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º null - —ç—Ç–æ—Ç —à–∞–±–ª–æ–Ω –Ω–µ –ø–æ–¥—Ö–æ–¥–∏—Ç
          return null;
        }

        // –£—Å–ª–æ–≤–∏–µ 3: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –æ—Ç—Ä–∏—Ü–∞–Ω–∏–µ –∏–ª–∏ –ø–æ–¥—Å–∫–∞–∑–∫–∞
        const remainingName = names.find(
          (n) =>
            n !== name1 || shuffledSurnames[names.indexOf(n)] !== wrongSurname,
        );
        const name1Surname = getSurname(name1);
        conditions.push({
          type: "notSurname",
          text: `<span class="highlight">${name2}</span> –Ω–µ <span class="highlight">${name1Surname}</span>.`,
          relevantInfo: {
            name: name2,
            notSurname: name1Surname,
            actualSurname: surname2,
          },
        });

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É—Å–ª–æ–≤–∏—è –¥–∞—é—Ç –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ
        if (!validatePuzzle(names, shuffledSurnames, conditions)) {
          return null;
        }

        const taskText = generateTaskTextV2(
          names,
          shuffledSurnames,
          conditions,
          personType,
        );
        const reasoning = generateReasoningV2(
          names,
          shuffledSurnames,
          conditions,
          personType,
        );

        return {
          text: taskText,
          names: names,
          surnames: shuffledSurnames,
          correctMatches: matches,
          reasoning: reasoning,
          conditions: conditions,
        };
      }

      // –®–∞–±–ª–æ–Ω 2: –° –±—É–∫–≤–∞–º–∏ –≤ —Ñ–∞–º–∏–ª–∏–∏
      function generateTemplate2(names, surnames, personType) {
        const isFemale = personType === "–¥–µ–≤–æ—á–∫–∏";

        // –ò—â–µ–º –∫–æ–º–±–∏–Ω–∞—Ü–∏—é, –≥–¥–µ –¥–≤–µ —Ñ–∞–º–∏–ª–∏–∏ –∏–º–µ—é—Ç –æ–±—â—É—é –±—É–∫–≤—É
        const permutations = getPermutations([...surnames]);

        for (const perm of permutations) {
          const getSurname = (name) => perm[names.indexOf(name)];

          // –ò—â–µ–º –æ–±—â—É—é –±—É–∫–≤—É —É –¥–≤—É—Ö —Ñ–∞–º–∏–ª–∏–π
          for (let i = 0; i < names.length; i++) {
            for (let j = i + 1; j < names.length; j++) {
              const si = perm[i].toLowerCase();
              const sj = perm[j].toLowerCase();

              for (const letter of si) {
                if (sj.includes(letter)) {
                  // –ù–∞—à–ª–∏ –æ–±—â—É—é –±—É–∫–≤—É!
                  const conditions = [];

                  // –£—Å–ª–æ–≤–∏–µ 1: –î–≤–∞ —á–µ–ª–æ–≤–µ–∫–∞ –∏–º–µ—é—Ç –æ–±—â—É—é –±—É–∫–≤—É
                  const nameiGen = declineNameGenitive(names[i], isFemale);
                  const namejGen = declineNameGenitive(names[j], isFemale);
                  conditions.push({
                    type: "sameLetterInSurname",
                    text: `–£ <span class="highlight">${nameiGen}</span> –∏ —É <span class="highlight">${namejGen}</span> –≤ —Ñ–∞–º–∏–ª–∏–∏ –µ—Å—Ç—å –±—É–∫–≤–∞ ¬´${letter.toUpperCase()}¬ª.`,
                    relevantInfo: {
                      person1: names[i],
                      person2: names[j],
                      letter: letter,
                      surnames: [perm[i], perm[j]],
                    },
                  });

                  // –£—Å–ª–æ–≤–∏–µ 2: –¢—Ä–µ—Ç–∏–π —á–µ–ª–æ–≤–µ–∫ –Ω–µ –∏–º–µ–µ—Ç —ç—Ç–æ–π –±—É–∫–≤—ã
                  const thirdIdx = 3 - i - j;
                  const thirdName = names[thirdIdx];
                  const thirdSurname = perm[thirdIdx];

                  if (!thirdSurname.toLowerCase().includes(letter)) {
                    conditions.push({
                      type: "notSurname",
                      text: `<span class="highlight">${thirdName}</span> –Ω–µ <span class="highlight">${perm[i]}</span>.`,
                      relevantInfo: {
                        name: thirdName,
                        notSurname: perm[i],
                        actualSurname: thirdSurname,
                      },
                    });

                    // –£—Å–ª–æ–≤–∏–µ 3: –ü–æ–¥—Å–∫–∞–∑–∫–∞ –¥–ª—è —Ä–∞–∑–ª–∏—á–µ–Ω–∏—è
                    conditions.push({
                      type: "notSurname",
                      text: `<span class="highlight">${names[i]}</span> –Ω–µ <span class="highlight">${perm[j]}</span>.`,
                      relevantInfo: {
                        name: names[i],
                        notSurname: perm[j],
                        actualSurname: perm[i],
                      },
                    });

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É—Å–ª–æ–≤–∏—è –¥–∞—é—Ç –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ
                    if (!validatePuzzle(names, perm, conditions)) {
                      continue;
                    }

                    const matches = names.map((name, idx) => ({
                      name: name,
                      surname: perm[idx],
                    }));

                    const taskText = generateTaskTextV2(
                      names,
                      perm,
                      conditions,
                      personType,
                    );
                    const reasoning = generateReasoningV2(
                      names,
                      perm,
                      conditions,
                      personType,
                    );

                    return {
                      text: taskText,
                      names: names,
                      surnames: perm,
                      correctMatches: matches,
                      reasoning: reasoning,
                      conditions: conditions,
                    };
                  }
                }
              }
            }
          }
        }

        return null;
      }

      // –®–∞–±–ª–æ–Ω 3: –° –ø–µ—Ä–≤—ã–º–∏ –±—É–∫–≤–∞–º–∏
      function generateTemplate3(names, surnames, personType) {
        const isFemale = personType === "–¥–µ–≤–æ—á–∫–∏";
        const permutations = getPermutations([...surnames]);

        for (const perm of permutations) {
          const conditions = [];

          // –ò—â–µ–º —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ –ø–µ—Ä–≤–æ–π –±—É–∫–≤—ã –∏–º–µ–Ω–∏ —Å –ø–µ—Ä–≤–æ–π –±—É–∫–≤–æ–π —Ñ–∞–º–∏–ª–∏–∏ –¥—Ä—É–≥–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞
          let foundMatch = false;
          for (let i = 0; i < names.length && !foundMatch; i++) {
            for (let j = 0; j < names.length && !foundMatch; j++) {
              if (
                i !== j &&
                names[i][0].toLowerCase() === perm[j][0].toLowerCase()
              ) {
                foundMatch = true;

                // –°–∫–ª–æ–Ω—è–µ–º –∏–º–µ–Ω–∞ –≤ —Ä–æ–¥–∏—Ç–µ–ª—å–Ω—ã–π –ø–∞–¥–µ–∂
                const name1Gen = declineNameGenitive(names[i], isFemale);
                const name2Gen = declineNameGenitive(names[j], isFemale);

                // –£—Å–ª–æ–≤–∏–µ 1: –ü–µ—Ä–≤–∞—è –±—É–∫–≤–∞ –∏–º–µ–Ω–∏ –ê —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø–µ—Ä–≤–æ–π –±—É–∫–≤–æ–π —Ñ–∞–º–∏–ª–∏–∏ –ë
                conditions.push({
                  type: "sameFirstLetter",
                  text: `–£ <span class="highlight">${name1Gen}</span> –ø–µ—Ä–≤–∞—è –±—É–∫–≤–∞ –∏–º–µ–Ω–∏ —Ç–∞–∫–∞—è –∂–µ, –∫–∞–∫ –ø–µ—Ä–≤–∞—è –±—É–∫–≤–∞ —Ñ–∞–º–∏–ª–∏–∏ —É <span class="highlight">${name2Gen}</span>.`,
                  relevantInfo: {
                    name1: names[i],
                    name2: names[j],
                    surname2: perm[j],
                  },
                });

                // –£—Å–ª–æ–≤–∏–µ 2: –ö—Ç–æ-—Ç–æ –Ω–µ –∏–º–µ–µ—Ç —Ñ–∞–º–∏–ª–∏—é
                const k = 3 - i - j;
                conditions.push({
                  type: "notSurname",
                  text: `<span class="highlight">${names[k]}</span> –Ω–µ <span class="highlight">${perm[i]}</span>.`,
                  relevantInfo: {
                    name: names[k],
                    notSurname: perm[i],
                    actualSurname: perm[k],
                  },
                });

                // –£—Å–ª–æ–≤–∏–µ 3: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –æ—Ç—Ä–∏—Ü–∞–Ω–∏–µ
                conditions.push({
                  type: "notSurname",
                  text: `<span class="highlight">${names[j]}</span> –Ω–µ <span class="highlight">${perm[k]}</span>.`,
                  relevantInfo: {
                    name: names[j],
                    notSurname: perm[k],
                    actualSurname: perm[j],
                  },
                });

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É—Å–ª–æ–≤–∏—è –¥–∞—é—Ç –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ
                if (!validatePuzzle(names, perm, conditions)) {
                  continue;
                }

                const matches = names.map((name, idx) => ({
                  name: name,
                  surname: perm[idx],
                }));

                const taskText = generateTaskTextV2(
                  names,
                  perm,
                  conditions,
                  personType,
                );
                const reasoning = generateReasoningV2(
                  names,
                  perm,
                  conditions,
                  personType,
                );

                return {
                  text: taskText,
                  names: names,
                  surnames: perm,
                  correctMatches: matches,
                  reasoning: reasoning,
                  conditions: conditions,
                };
              }
            }
          }
        }

        return null;
      }

      // –®–∞–±–ª–æ–Ω 4: –ö–æ–º–±–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π (—Å —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ–º –ø–µ—Ä–≤—ã—Ö –±—É–∫–≤)
      function generateTemplate4(names, surnames, personType) {
        const isFemale = personType === "–¥–µ–≤–æ—á–∫–∏";
        const permutations = getPermutations([...surnames]);

        for (const perm of permutations) {
          const conditions = [];

          // –ò—â–µ–º —á–µ–ª–æ–≤–µ–∫–∞, —É –∫–æ—Ç–æ—Ä–æ–≥–æ –ø–µ—Ä–≤–∞—è –±—É–∫–≤–∞ –∏–º–µ–Ω–∏ —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø–µ—Ä–≤–æ–π –±—É–∫–≤–æ–π –µ–≥–æ —Ñ–∞–º–∏–ª–∏–∏
          // –ò –ø—Ä–∏ —ç—Ç–æ–º –ù–ï–¢ –¥—Ä—É–≥–æ–π —Ñ–∞–º–∏–ª–∏–∏ –Ω–∞ —Ç—É –∂–µ –±—É–∫–≤—É (–¥–ª—è –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ—Å—Ç–∏)
          let matchIdx = -1;
          for (let i = 0; i < names.length; i++) {
            if (names[i][0].toLowerCase() === perm[i][0].toLowerCase()) {
              // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –Ω–µ—Ç –¥—Ä—É–≥–æ–π —Ñ–∞–º–∏–ª–∏–∏ –Ω–∞ —Ç—É –∂–µ –±—É–∫–≤—É
              const letter = perm[i][0].toLowerCase();
              const surnamesWithSameLetter = perm.filter(
                (s) => s[0].toLowerCase() === letter,
              );
              if (surnamesWithSameLetter.length === 1) {
                matchIdx = i;
                break;
              }
            }
          }

          if (matchIdx === -1) continue;

          // –°–∫–ª–æ–Ω—è–µ–º –∏–º—è –≤ —Ä–æ–¥–∏—Ç–µ–ª—å–Ω—ã–π –ø–∞–¥–µ–∂
          const matchedNameGen = declineNameGenitive(names[matchIdx], isFemale);

          // –£—Å–ª–æ–≤–∏–µ 1: –£ —ç—Ç–æ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞ –ø–µ—Ä–≤—ã–µ –±—É–∫–≤—ã —Å–æ–≤–ø–∞–¥–∞—é—Ç
          conditions.push({
            type: "sameFirstLetterOwn",
            text: `–£ <span class="highlight">${matchedNameGen}</span> –ø–µ—Ä–≤–∞—è –±—É–∫–≤–∞ –∏–º–µ–Ω–∏ –∏ —Ñ–∞–º–∏–ª–∏–∏ —Å–æ–≤–ø–∞–¥–∞—é—Ç.`,
            relevantInfo: { name: names[matchIdx], surname: perm[matchIdx] },
          });

          // –£—Å–ª–æ–≤–∏–µ 2: –ö—Ç–æ-—Ç–æ –ù–ï –∏–º–µ–µ—Ç —Ñ–∞–º–∏–ª–∏—é (–æ—Ç—Ä–∏—Ü–∞–Ω–∏–µ)
          const otherIdx1 = (matchIdx + 1) % 3;
          const otherIdx2 = (matchIdx + 2) % 3;
          conditions.push({
            type: "notSurname",
            text: `<span class="highlight">${names[otherIdx1]}</span> –Ω–µ <span class="highlight">${perm[matchIdx]}</span>.`,
            relevantInfo: {
              name: names[otherIdx1],
              notSurname: perm[matchIdx],
              actualSurname: perm[otherIdx1],
            },
          });

          // –£—Å–ª–æ–≤–∏–µ 3: –ï—â—ë –æ–¥–Ω–æ –æ—Ç—Ä–∏—Ü–∞–Ω–∏–µ
          conditions.push({
            type: "notSurname",
            text: `<span class="highlight">${names[otherIdx2]}</span> –Ω–µ <span class="highlight">${perm[otherIdx1]}</span>.`,
            relevantInfo: {
              name: names[otherIdx2],
              notSurname: perm[otherIdx1],
              actualSurname: perm[otherIdx2],
            },
          });

          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É—Å–ª–æ–≤–∏—è –¥–∞—é—Ç –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ
          if (!validatePuzzle(names, perm, conditions)) {
            continue;
          }

          const matches = names.map((name, idx) => ({
            name: name,
            surname: perm[idx],
          }));

          const taskText = generateTaskTextV2(
            names,
            perm,
            conditions,
            personType,
          );
          const reasoning = generateReasoningV2(
            names,
            perm,
            conditions,
            personType,
          );

          return {
            text: taskText,
            names: names,
            surnames: perm,
            correctMatches: matches,
            reasoning: reasoning,
            conditions: conditions,
          };
        }

        return null;
      }

      // –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ —É—Å–ª–æ–≤–∏—è –¥–∞—é—Ç –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ
      function validatePuzzle(names, surnames, conditions) {
        // –°—Ç—Ä–æ–∏–º –º–∞—Ç—Ä–∏—Ü—É –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–π
        const possible = {};
        names.forEach((name) => {
          possible[name] = new Set(surnames);
        });

        // –ü—Ä–∏–º–µ–Ω—è–µ–º —É—Å–ª–æ–≤–∏—è –¥–ª—è —Å—É–∂–µ–Ω–∏—è –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
        for (const condition of conditions) {
          if (condition.type === "notSurname") {
            const { name, notSurname } = condition.relevantInfo;
            possible[name].delete(notSurname);
          } else if (condition.type === "sameLetterInSurname") {
            const {
              person1,
              person2,
              surnames: condSurnames,
            } = condition.relevantInfo;
            // –≠—Ç–∏ –¥–≤–∞ —á–µ–ª–æ–≤–µ–∫–∞ –∏–º–µ—é—Ç —Ñ–∞–º–∏–ª–∏–∏ –∏–∑ condSurnames
            // –°—É–∂–∞–µ–º –∏—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –¥–æ —ç—Ç–∏—Ö –¥–≤—É—Ö —Ñ–∞–º–∏–ª–∏–π
            const otherSurname = names.find(
              (n) => n !== person1 && n !== person2,
            );
            // –£–¥–∞–ª—è–µ–º —ç—Ç–∏ —Ñ–∞–º–∏–ª–∏–∏ —É —Ç—Ä–µ—Ç—å–µ–≥–æ —á–µ–ª–æ–≤–µ–∫–∞
            if (otherSurname) {
              possible[otherSurname].delete(condSurnames[0]);
              possible[otherSurname].delete(condSurnames[1]);
            }
          } else if (condition.type === "sameFirstLetterOwn") {
            const { name, surname } = condition.relevantInfo;
            // –ü—Ä—è–º–æ–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ
            possible[name] = new Set([surname]);
            // –£–¥–∞–ª—è–µ–º —ç—Ç—É —Ñ–∞–º–∏–ª–∏—é —É –¥—Ä—É–≥–∏—Ö
            names.forEach((n) => {
              if (n !== name) possible[n].delete(surname);
            });
          } else if (condition.type === "sameFirstLetter") {
            const { name2, surname2 } = condition.relevantInfo;
            // name2 –∏–º–µ–µ—Ç surname2
            possible[name2] = new Set([surname2]);
            names.forEach((n) => {
              if (n !== name2) possible[n].delete(surname2);
            });
          }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –∫–∞–∂–¥—ã–π —á–µ–ª–æ–≤–µ–∫ –∏–º–µ–µ—Ç —Ä–æ–≤–Ω–æ –æ–¥–Ω—É –≤–æ–∑–º–æ–∂–Ω—É—é —Ñ–∞–º–∏–ª–∏—é
        // –∏ –∫–∞–∂–¥–∞—è —Ñ–∞–º–∏–ª–∏—è –Ω–∞–∑–Ω–∞—á–µ–Ω–∞ —Ä–æ–≤–Ω–æ –æ–¥–Ω–æ–º—É —á–µ–ª–æ–≤–µ–∫—É
        let changed = true;
        while (changed) {
          changed = false;
          for (const name of names) {
            if (possible[name].size === 1) {
              const surname = [...possible[name]][0];
              // –£–¥–∞–ª—è–µ–º —ç—Ç—É —Ñ–∞–º–∏–ª–∏—é —É –¥—Ä—É–≥–∏—Ö
              for (const otherName of names) {
                if (otherName !== name && possible[otherName].has(surname)) {
                  possible[otherName].delete(surname);
                  changed = true;
                }
              }
            }
          }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ—Å—Ç—å
        for (const name of names) {
          if (possible[name].size !== 1) {
            return false;
          }
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤—Å–µ —Ñ–∞–º–∏–ª–∏–∏ —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω—ã
        const assignedSurnames = new Set(names.map((n) => [...possible[n]][0]));
        if (assignedSurnames.size !== names.length) {
          return false;
        }

        return true;
      }

      // –ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ –º–∞—Å—Å–∏–≤–∞
      function getPermutations(arr) {
        if (arr.length <= 2) {
          return arr.length === 2 ? [arr, [arr[1], arr[0]]] : [arr];
        }
        return arr.reduce(
          (acc, item, i) =>
            acc.concat(
              getPermutations([...arr.slice(0, i), ...arr.slice(i + 1)]).map(
                (val) => [item, ...val],
              ),
            ),
          [],
        );
      }

      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞ –∑–∞–¥–∞—á–∏ (–Ω–æ–≤–∞—è –≤–µ—Ä—Å–∏—è)
      function generateTaskTextV2(names, surnames, conditions, personType) {
        const namesList = names.join(", ");
        const surnamesList = surnames.join(", ");
        const isFemale = personType === "–¥–µ–≤–æ—á–∫–∏";

        let taskText = `–¢—Ä–æ–µ ${isFemale ? "–ø–æ–¥—Ä—É–≥" : "–¥—Ä—É–∑–µ–π"} ${
          isFemale ? "–ø—Ä–∞–∑–¥–Ω—É—é—Ç –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è" : "–ø—Ä–∞–∑–¥–Ω—É—é—Ç –¥–µ–Ω—å —Ä–æ–∂–¥–µ–Ω–∏—è"
        }: <span class="highlight">${namesList}</span>. `;
        taskText += `–ò—Ö —Ñ–∞–º–∏–ª–∏–∏: <span class="highlight">${surnamesList}</span>. `;

        // –î–æ–±–∞–≤–ª—è–µ–º —É—Å–ª–æ–≤–∏—è
        conditions.forEach((condition, idx) => {
          taskText += `<br><strong>${idx + 1})</strong> ${condition.text}`;
        });

        taskText += `<br>–ó–∞–ø–æ–ª–Ω–∏—Ç–µ —Ç–∞–±–ª–∏—Ü—É: –ø–æ—Å—Ç–∞–≤—å—Ç–µ <strong>+</strong> —Ç–∞–º, –≥–¥–µ –∏–º—è –∏ —Ñ–∞–º–∏–ª–∏—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç –¥—Ä—É–≥ –¥—Ä—É–≥—É, –∏ <strong>‚àí</strong> –≥–¥–µ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—Ç.`;

        return taskText;
      }

      // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ä–∞—Å—Å—É–∂–¥–µ–Ω–∏–π –¥–ª—è —Ä–µ—à–µ–Ω–∏—è (–Ω–æ–≤–∞—è –≤–µ—Ä—Å–∏—è)
      function generateReasoningV2(names, surnames, conditions, personType) {
        const steps = [];
        const isFemale = personType === "–¥–µ–≤–æ—á–∫–∏";
        const getIdx = (name) => names.indexOf(name);
        const getSurname = (name) => surnames[getIdx(name)];

        // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —É—Å–ª–æ–≤–∏—è –∏ —Å—Ç—Ä–æ–∏–º –ª–æ–≥–∏—á–µ—Å–∫—É—é —Ü–µ–ø–æ—á–∫—É
        const knownMatches = new Map(); // –∏–º—è -> —Ñ–∞–º–∏–ª–∏—è
        const excludedSurnames = new Map(); // –∏–º—è -> Set —Ñ–∞–º–∏–ª–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –ù–ï –ø–æ–¥—Ö–æ–¥—è—Ç

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥–æ–µ —É—Å–ª–æ–≤–∏–µ
        for (const condition of conditions) {
          switch (condition.type) {
            case "notSurname": {
              const { name, notSurname, actualSurname } =
                condition.relevantInfo;
              if (!excludedSurnames.has(name)) {
                excludedSurnames.set(name, new Set());
              }
              excludedSurnames.get(name).add(notSurname);
              steps.push(
                `–ò–∑ —É—Å–ª–æ–≤–∏—è —Å–ª–µ–¥—É–µ—Ç, —á—Ç–æ <span class="highlight">${name}</span> –Ω–µ <span class="highlight">${notSurname}</span>.`,
              );
              break;
            }

            case "sameLetterInSurname": {
              const {
                person1,
                person2,
                letter,
                surnames: condSurnames,
              } = condition.relevantInfo;
              const upperLetter = letter.toUpperCase();
              steps.push(
                `<span class="highlight">${person1}</span> –∏ <span class="highlight">${person2}</span> –∏–º–µ—é—Ç –≤ —Ñ–∞–º–∏–ª–∏–∏ –±—É–∫–≤—É ¬´${upperLetter}¬ª. –ó–Ω–∞—á–∏—Ç, –∏—Ö —Ñ–∞–º–∏–ª–∏–∏ ‚Äì <span class="highlight">${condSurnames[0]}</span> –∏ <span class="highlight">${condSurnames[1]}</span>.`,
              );

              // –ï—Å–ª–∏ –∑–Ω–∞–µ–º –æ–¥–Ω—É —Ñ–∞–º–∏–ª–∏—é, –º–æ–∂–µ–º –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –¥—Ä—É–≥—É—é
              if (knownMatches.has(person1)) {
                knownMatches.set(
                  person2,
                  condSurnames.find((s) => s !== knownMatches.get(person1)),
                );
              } else if (knownMatches.has(person2)) {
                knownMatches.set(
                  person1,
                  condSurnames.find((s) => s !== knownMatches.get(person2)),
                );
              }
              break;
            }

            case "sameFirstLetter": {
              const { name1, name2, surname2 } = condition.relevantInfo;
              steps.push(
                `–£ <span class="highlight">${name1}</span> –∏–º—è –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å ¬´${name1[0].toUpperCase()}¬ª, –∑–Ω–∞—á–∏—Ç —Ñ–∞–º–∏–ª–∏—è <span class="highlight">${name2}</span> ‚Äì <span class="highlight">${surname2}</span>.`,
              );
              knownMatches.set(name2, surname2);
              break;
            }

            case "differentFirstLetter": {
              const { name, surname } = condition.relevantInfo;
              steps.push(
                `–£ <span class="highlight">${name}</span> –ø–µ—Ä–≤–∞—è –±—É–∫–≤–∞ –∏–º–µ–Ω–∏ (${name[0].toUpperCase()}) –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –ø–µ—Ä–≤–æ–π –±—É–∫–≤—ã —Ñ–∞–º–∏–ª–∏–∏. –≠—Ç–æ —É—Å–ª–æ–≤–∏–µ –ø–æ–º–æ–≥–∞–µ—Ç –æ—Ç—Å–µ—è—Ç—å –≤–∞—Ä–∏–∞–Ω—Ç—ã.`,
              );
              break;
            }

            case "letterInName": {
              const { name1, name2, surname2, letter } = condition.relevantInfo;
              steps.push(
                `–í —Ñ–∞–º–∏–ª–∏–∏ <span class="highlight">${surname2}</span> –µ—Å—Ç—å –±—É–∫–≤–∞ –∏–∑ –∏–º–µ–Ω–∏ <span class="highlight">${name1}</span>. –§–∞–º–∏–ª–∏—è <span class="highlight">${name2}</span> ‚Äì <span class="highlight">${surname2}</span>.`,
              );
              knownMatches.set(name2, surname2);
              break;
            }

            case "differentFirstLetterSimple": {
              const { name1, name2, surname2 } = condition.relevantInfo;
              steps.push(
                `–£ <span class="highlight">${name1}</span> –∏ —Ñ–∞–º–∏–ª–∏–∏ <span class="highlight">${surname2}</span> –ø–µ—Ä–≤—ã–µ –±—É–∫–≤—ã —Ä–∞–∑–Ω—ã–µ. –≠—Ç–æ –∏—Å–∫–ª—é—á–∞–µ—Ç –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã.`,
              );
              break;
            }

            case "sameFirstLetterOwn": {
              const { name, surname } = condition.relevantInfo;
              steps.push(
                `–£ <span class="highlight">${name}</span> –ø–µ—Ä–≤–∞—è –±—É–∫–≤–∞ –∏–º–µ–Ω–∏ ¬´${name[0].toUpperCase()}¬ª —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –ø–µ—Ä–≤–æ–π –±—É–∫–≤–æ–π —Ñ–∞–º–∏–ª–∏–∏ ¬´${surname[0].toUpperCase()}¬ª. –ó–Ω–∞—á–∏—Ç, <span class="highlight">${name}</span> ‚Äì <span class="highlight">${surname}</span>.`,
              );
              knownMatches.set(name, surname);
              break;
            }
          }
        }

        // –î–æ–±–∞–≤–ª—è–µ–º –∏—Ç–æ–≥–æ–≤—ã–π –≤—ã–≤–æ–¥
        const foundMatches = [];
        for (const name of names) {
          const surname = getSurname(name);
          if (knownMatches.has(name)) {
            foundMatches.push(
              `<span class="highlight">${name}</span> ‚Äì <span class="highlight">${surname}</span>`,
            );
          }
        }

        if (foundMatches.length > 0) {
          steps.push(`–û—Ç–≤–µ—Ç: ${foundMatches.join(", ")}.`);
        } else {
          // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤—ã–≤–µ—Å—Ç–∏, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ—Ç–≤–µ—Ç
          const allMatches = names.map(
            (n) =>
              `<span class="highlight">${n}</span> ‚Äì <span class="highlight">${getSurname(n)}</span>`,
          );
          steps.push(
            `–ü—É—Ç—ë–º –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö —Ä–∞—Å—Å—É–∂–¥–µ–Ω–∏–π –æ–ø—Ä–µ–¥–µ–ª—è–µ–º: ${allMatches.join(", ")}.`,
          );
        }

        return steps;
      }

      // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è –º–∞—Å—Å–∏–≤–∞
      function shuffleArray(arr) {
        const result = [...arr];
        for (let i = result.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [result[i], result[j]] = [result[j], result[i]];
        }
        return result;
      }

      // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –∑–∞–¥–∞–Ω–∏—è
      function renderTask() {
        document.getElementById("taskText").innerHTML = currentTask.text;

        // –ü–µ—Ä–µ–º–µ—à–∏–≤–∞–µ–º –ø–æ—Ä—è–¥–æ–∫ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∏–º—ë–Ω (—Å—Ç—Ä–æ–∫–∏) –∏ —Ñ–∞–º–∏–ª–∏–π (—Å—Ç–æ–ª–±—Ü—ã)
        const nameOrder = shuffleArray([0, 1, 2]);
        const surnameOrder = shuffleArray([0, 1, 2]);

        const displayNames = nameOrder.map((i) => currentTask.names[i]);
        const displaySurnames = surnameOrder.map(
          (i) => currentTask.surnames[i],
        );

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø–æ—Ä—è–¥–æ–∫ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
        currentTask.displayNameOrder = nameOrder;
        currentTask.displaySurnameOrder = surnameOrder;

        // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–∫–∏ —Ç–∞–±–ª–∏—Ü—ã
        document.getElementById("surname1").textContent = displaySurnames[0];
        document.getElementById("surname2").textContent = displaySurnames[1];
        document.getElementById("surname3").textContent = displaySurnames[2];

        // –û—Ç—Ä–∏—Å–æ–≤—ã–≤–∞–µ–º —Å—Ç—Ä–æ–∫–∏ —Ç–∞–±–ª–∏—Ü—ã
        const tableBody = document.getElementById("tableBody");
        tableBody.innerHTML = "";

        displayNames.forEach((name, displayRowIdx) => {
          const originalRowIdx = nameOrder[displayRowIdx];
          const row = document.createElement("tr");

          // –Ø—á–µ–π–∫–∞ —Å –∏–º–µ–Ω–µ–º
          const nameCell = document.createElement("td");
          nameCell.className = "name-cell";
          nameCell.textContent = name;
          row.appendChild(nameCell);

          // –Ø—á–µ–π–∫–∏ –¥–ª—è –∫–ª–∏–∫–æ–≤
          displaySurnames.forEach((surname, displayColIdx) => {
            const originalColIdx = surnameOrder[displayColIdx];
            const cell = document.createElement("td");
            cell.className = "clickable";
            cell.dataset.displayRow = displayRowIdx;
            cell.dataset.displayCol = displayColIdx;
            cell.dataset.originalRow = originalRowIdx;
            cell.dataset.originalCol = originalColIdx;
            cell.dataset.name = name;
            cell.dataset.surname = surname;

            cell.addEventListener("click", handleCellClick);

            row.appendChild(cell);
          });

          tableBody.appendChild(row);
        });
      }

      // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–ª–∏–∫–∞ –ø–æ —è—á–µ–π–∫–µ
      function handleCellClick(e) {
        const cell = e.target;
        const currentState = cell.dataset.state || "empty";

        // –¶–∏–∫–ª–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ: –ø—É—Å—Ç–æ -> + -> - -> –ø—É—Å—Ç–æ
        switch (currentState) {
          case "empty":
            cell.dataset.state = "plus";
            cell.className = "clickable plus";
            cell.textContent = "+";
            break;
          case "plus":
            cell.dataset.state = "minus";
            cell.className = "clickable minus";
            cell.textContent = "‚àí";
            break;
          case "minus":
            cell.dataset.state = "empty";
            cell.className = "clickable";
            cell.textContent = "";
            break;
        }
      }

      // –ü—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–≤–µ—Ç–∞
      function checkAnswer() {
        if (answered) return;

        const cells = document.querySelectorAll(".clickable");
        let allFilled = true;
        let correctCount = 0;
        let totalCells = cells.length;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –≤—Å–µ –ª–∏ —è—á–µ–π–∫–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã
        cells.forEach((cell) => {
          if (!cell.dataset.state || cell.dataset.state === "empty") {
            allFilled = false;
          }
        });

        if (!allFilled) {
          alert("–ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ —è—á–µ–π–∫–∏ —Ç–∞–±–ª–∏—Ü—ã!");
          return;
        }

        answered = true;

        // –°—Ç—Ä–æ–∏–º –ø—Ä–∞–≤–∏–ª—å–Ω—É—é –º–∞—Ç—Ä–∏—Ü—É –æ—Ç–≤–µ—Ç–æ–≤ (–≤ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã—Ö –∏–Ω–¥–µ–∫—Å–∞—Ö)
        const correctMatrix = [];
        currentTask.names.forEach((name, rowIdx) => {
          const row = [];
          currentTask.surnames.forEach((surname, colIdx) => {
            const match = currentTask.correctMatches.find(
              (m) => m.name === name,
            );
            row.push(match.surname === surname ? "plus" : "minus");
          });
          correctMatrix.push(row);
        });

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—É—é —è—á–µ–π–∫—É, –∏—Å–ø–æ–ª—å–∑—É—è –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –∏–Ω–¥–µ–∫—Å—ã
        cells.forEach((cell) => {
          const originalRow = parseInt(cell.dataset.originalRow);
          const originalCol = parseInt(cell.dataset.originalCol);
          const userState = cell.dataset.state;
          const correctState = correctMatrix[originalRow][originalCol];

          if (userState === correctState) {
            correctCount++;
            if (userState === "plus") {
              cell.classList.add("correct");
            } else {
              cell.classList.add("correct-minus");
            }
          } else {
            cell.classList.add("incorrect");
          }
        });

        const feedback = document.getElementById("feedback");
        const feedbackText = document.getElementById("feedbackText");

        if (correctCount === totalCells) {
          feedback.className = "feedback correct";
          feedbackText.textContent = "üéâ –û—Ç–ª–∏—á–Ω–æ! –í—Å–µ —è—á–µ–π–∫–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã –≤–µ—Ä–Ω–æ!";
        } else {
          feedback.className = "feedback incorrect";
          feedbackText.textContent = `‚ùå –ü—Ä–∞–≤–∏–ª—å–Ω–æ: ${correctCount} –∏–∑ ${totalCells}`;

          let correctAnswer = "–ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã: ";
          currentTask.correctMatches.forEach((m, i) => {
            correctAnswer += `${m.name} - ${m.surname}`;
            if (i < currentTask.correctMatches.length - 1)
              correctAnswer += ", ";
          });
          document.getElementById("correctAnswer").textContent = correctAnswer;
        }

        feedback.style.display = "block";

        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ö–æ–¥ —Ä–∞—Å—Å—É–∂–¥–µ–Ω–∏–π
        if (currentTask.reasoning && currentTask.reasoning.length > 0) {
          const reasoningSteps = document.getElementById("reasoningSteps");
          const reasoningList = document.getElementById("reasoningList");
          reasoningList.innerHTML = "";

          currentTask.reasoning.forEach((step) => {
            const li = document.createElement("li");
            li.innerHTML = step;
            reasoningList.appendChild(li);
          });

          reasoningSteps.style.display = "block";
        }
      }

      // –û—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö —è—á–µ–µ–∫
      function clearAll() {
        const cells = document.querySelectorAll(".clickable");
        cells.forEach((cell) => {
          cell.dataset.state = "empty";
          cell.className = "clickable";
          cell.textContent = "";
        });

        document.getElementById("feedback").style.display = "none";
        document.getElementById("reasoningSteps").style.display = "none";
        answered = false;
      }

      // –°–±—Ä–æ—Å –∏–≥—Ä—ã
      function resetGame() {
        startGame();
      }

      // –ó–∞–ø—É—Å–∫
      loadData();
    </script>
  </body>
</html>
